package dotnet.sort.data.quiz.generator

import dotnet.sort.domain.model.SortType
import dotnet.sort.domain.quiz.generator.QuizGenerator
import dotnet.sort.domain.quiz.model.QuizQuestion
import dotnet.sort.domain.algorithm.SortAlgorithmFactory
import dotnet.sort.domain.generator.ArrayGenerator
import dotnet.sort.domain.generator.ArrayGeneratorType
import kotlin.random.Random
import org.koin.core.annotation.Single

@Single
class QuizGeneratorImpl(
    private val arrayGenerator: ArrayGenerator
) : QuizGenerator {
    
    private var questionIdCounter = 0

    override fun generate(type: SortType, arraySize: Int): QuizQuestion {
        // 1. Generate a random array
        val array = arrayGenerator.generate(arraySize, ArrayGeneratorType.RANDOM)
        
        // 2. Run the algorithm to get steps
        val algorithm = SortAlgorithmFactory.create(type)
        val result = algorithm.sort(array)
        
        // 3. Filter steps that involve a swap
        // Find steps where array content changed (Swap)
        val swapSteps = mutableListOf<Int>()
        for (i in 0 until result.steps.size - 1) {
             val current = result.steps[i].arrayState
             val next = result.steps[i+1].arrayState
             if (current != next) {
                 swapSteps.add(i)
             }
        }
        
        if (swapSteps.isEmpty()) {
             // Fallback if no swaps (e.g. already sorted array generated by chance)
             // Retry
             return generate(type, arraySize)
        }
        
        // 4. Pick a random swap step
        val stepIndex = swapSteps.random()
        val currentSnapshot = result.steps[stepIndex]
        val nextSnapshot = result.steps[stepIndex + 1]
        
        // 5. Identify swapped indices
        val swappedIndices = mutableListOf<Int>()
        val currentArrayState = currentSnapshot.arrayState
        val nextArrayState = nextSnapshot.arrayState
        
        for (i in currentArrayState.indices) {
            if (currentArrayState[i] != nextArrayState[i]) {
                swappedIndices.add(i)
            }
        }
        
        // Ideally exactly 2 indices for a simple swap
        val answer = if (swappedIndices.size == 2) {
            swappedIndices[0] to swappedIndices[1]
        } else {
            // Complex swap or multiple changes? Just pick first two or fallback
            // For simple sorts, it's usually 2.
            if (swappedIndices.size >= 2) swappedIndices[0] to swappedIndices[1] else 0 to 0
        }
        
        return QuizQuestion(
            id = "quiz_${questionIdCounter++}",
            algorithmType = type,
            currentArray = currentArrayState,
            correctIndices = if (answer.first < answer.second) answer else answer.second to answer.first, // Normalize order
            timeLimitSeconds = 10
        )
    }
}
